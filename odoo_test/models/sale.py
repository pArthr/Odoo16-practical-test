# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details

import logging

from odoo.tools import float_compare
from odoo import _, api, fields, models
from odoo.exceptions import ValidationError
from datetime import timedelta



class SaleOrder(models.Model):
    _inherit = "sale.order"

    split_delivery = fields.Boolean("Split Delivery")
    delivery_date = fields.Date(string="Delivery Date")

    def action_confirm(self):
        for order in self:
            if order.split_delivery:
                if not order.delivery_date:
                    raise ValidationError(_('Please assign Delivery Date.'))
                if order.order_line:
                    #lines = order.order_line.filtered(lambda l: not l.planned_date)

                    lines = order.order_line.filtered(lambda l: not l.planned_date)
                    if lines:
                        lines.write({'planned_date': order.delivery_date})
        res = super(SaleOrder, self).action_confirm()
        return res


class SaleOrderLine(models.Model):
    _inherit = "sale.order.line"

    planned_date = fields.Date(string="Planned Date")

    def _action_launch_stock_rule(self, previous_product_uom_qty=False):
        """
        Launch procurement group run method with required/custom fields generated by a
        sale order line. procurement group will launch '_run_pull', '_run_buy' or '_run_manufacture'
        depending on the sale order line product rule.
        """
        split_delivery = False
        if any(line.order_id.split_delivery for line in self):
        	split_delivery = True
        if split_delivery:
        	self = self.sorted('planned_date')
        	planned_date_lst = []
        if self._context.get("skip_procurement"):
            return True
        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
        procurements = []

        for line in self:
            line = line.with_company(line.company_id)
            if line.state != 'sale' or not line.product_id.type in ('consu', 'product'):
                continue
            qty = line._get_qty_procurement(previous_product_uom_qty)
            if float_compare(qty, line.product_uom_qty, precision_digits=precision) == 0:
                continue
            if split_delivery:#cust
                if line.planned_date not in planned_date_lst:
                    planned_date_lst.append(line.planned_date)
                    #manage qty existing line update
                    if line.product_uom_qty != qty:
                        picking_rec = line.order_id.picking_ids.filtered( lambda p: p.state not in ['done', 'cancel'] and p.scheduled_date.date() == line.planned_date)
                        if picking_rec:
                            group_id = picking_rec.group_id
                        else:
                            group_id = False
                    else:
                        group_id = False
                else:
                    group_id = line._get_procurement_group()
            else:#def
                group_id = line._get_procurement_group()
            if not group_id:

                group_id = self.env['procurement.group'].create(line._prepare_procurement_group_vals())
                line.order_id.procurement_group_id = group_id
            else:
                # In case the procurement group is already created and the order was
                # cancelled, we need to update certain values of the group.
                updated_vals = {}
                if group_id.partner_id != line.order_id.partner_shipping_id:
                    updated_vals.update({'partner_id': line.order_id.partner_shipping_id.id})
                if group_id.move_type != line.order_id.picking_policy:
                    updated_vals.update({'move_type': line.order_id.picking_policy})
                if updated_vals:
                    group_id.write(updated_vals)

            values = line._prepare_procurement_values(group_id=group_id)
            product_qty = line.product_uom_qty - qty

            line_uom = line.product_uom
            quant_uom = line.product_id.uom_id
            product_qty, procurement_uom = line_uom._adjust_uom_quantities(product_qty, quant_uom)
            procurements.append(self.env['procurement.group'].Procurement(
                line.product_id, product_qty, procurement_uom,
                line.order_id.partner_shipping_id.property_stock_customer,
                line.product_id.display_name, line.order_id.name, line.order_id.company_id, values))
        if procurements:
            procurement_group = self.env['procurement.group']
            if self.env.context.get('import_file'):
                procurement_group = procurement_group.with_context(import_file=False)
            procurement_group.run(procurements)

        # This next block is currently needed only because the scheduler trigger is done by picking confirmation rather than stock.move confirmation
        orders = self.mapped('order_id')
        for order in orders:
            pickings_to_confirm = order.picking_ids.filtered(lambda p: p.state not in ['cancel', 'done'])
            if pickings_to_confirm:
                # Trigger the Scheduler for Pickings
                pickings_to_confirm.action_confirm()
        return True

    def _prepare_procurement_values(self, group_id=False):
        """ Prepare specific key for moves or other components that will be created from a stock rule
        coming from a sale order line. This method could be override in order to add other custom key that could
        be used in move/po creation.
        """
        values = super(SaleOrderLine, self)._prepare_procurement_values(group_id)
        self.ensure_one()
        # Use the delivery date if there is else use date_order and lead time
        date_deadline = self.order_id.commitment_date or (self.order_id.date_order + timedelta(days=self.customer_lead or 0.0))
        if self.order_id.split_delivery:
            date_planned = self.planned_date
        else:
            date_planned = date_deadline - timedelta(days=self.order_id.company_id.security_lead)
        values.update({
            'group_id': group_id,
            'sale_line_id': self.id,
            'date_planned': date_planned,
            'date_deadline': date_deadline,
            'route_ids': self.route_id,
            'warehouse_id': self.order_id.warehouse_id or False,
            'partner_id': self.order_id.partner_shipping_id.id,
            'product_description_variants': self.with_context(lang=self.order_id.partner_id.lang)._get_sale_order_line_multiline_description_variants(),
            'company_id': self.order_id.company_id,
            'product_packaging_id': self.product_packaging_id,
            'sequence': self.sequence,
        })
        return values

# vim:expandtab:smartindent:tabstop=4:softtabstop=4:shiftwidth=4:
